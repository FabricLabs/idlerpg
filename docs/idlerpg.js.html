<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Source: idlerpg.js &middot; Documentation</title>
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  </head>
  <body>
    <div id="main">
      <h1 class="page-title">Source: idlerpg.js</h1>
      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const util = require('util');
const article = require('indefinite-article');
const manager = require('fast-json-patch');
const pointer = require('json-pointer');
const schedule = require('node-schedule');

const Entity = require('./entity');
const Fabric = require('./fabric');

const PER_TICK_CAPITAL = 10;
const PER_TICK_EXPERIENCE = 10;
const TICK_INTERVAL = 10000;
const ENCOUNTER_CHANCE = 0.05;

/**
 * The main IdleRPG constructor.
 * @param       {Object} config Configuration object.
 * @param       {Object} config.interval Tick interval (in milliseconds).
 * @constructor
 */
function IdleRPG(config) {
    this.config = Object.assign({
        name: 'idlerpg',
        alias: '@idlerpg:verse.im',
        channels: ['idlerpg'],
        interval: TICK_INTERVAL,
        luck: ENCOUNTER_CHANCE,
        PER_TICK_CAPITAL: PER_TICK_CAPITAL,
        PER_TICK_EXPERIENCE: PER_TICK_EXPERIENCE
    }, config);

    this.channels = [];
    this.stack = [];

    this.state = {
        channels: {},
        players: {},
        services: {},
        users: {}
    };

    this.fabric = new Fabric();
    this.observer = manager.observe(this.state);
    this.triggers = [
        { name: 'online', value: this._handleOnlineRequest },
        { name: 'memberlist', value: this._handleMemberlistRequest },
        { name: 'play', value: this._handlePlayRequest },
        { name: 'profile', value: this._handleProfileRequest },
        { name: 'inventory', value: this._handleInventoryRequest },
        { name: 'leaderboard', value: this._handleLeaderboardRequest },
        { name: 'transfer', value: this._handleTransferRequest },
        { name: 'balance', value: this._handleBalanceRequest }
    ];

    return this;
}

util.inherits(IdleRPG, Fabric);

/**
 * Entry point for running IdleRPG.  Creates a datastore, subscribes to events,
 * initializes the clock, and emits a "ready" event when complete.
 * @return {IdleRPG} Chainable method.
 */
IdleRPG.prototype.start = async function() {
    console.log('IdleRPG starting...');

    let rpg = this;

    rpg.store = new Fabric.Store({ path: './data/idlerpg' });

    try {
        let state = await rpg.store.get('/');
        let parsed = JSON.parse(state);
        let merged = Object.assign({}, rpg.state, parsed);
        rpg.state = merged;
    } catch (E) {
        console.error('Could not restore state:', E);
    }

    rpg.fabric.on('join', rpg._handleJoin.bind(rpg));
    rpg.fabric.on('part', rpg._disjoinPlayer.bind(rpg));
    rpg.fabric.on('user', rpg._registerUser.bind(rpg));
    rpg.fabric.on('channel', rpg._registerChannel.bind(rpg));
    rpg.fabric.on('message', rpg._handleMessage.bind(rpg));
    rpg.fabric.on('service', rpg._registerService.bind(rpg));
    rpg.fabric.on('patch', rpg._handlePatch.bind(rpg));
    rpg.fabric.on('patches', rpg._handlePatches.bind(rpg));

    for (let name in rpg.fabric.services) {
        let service = rpg.fabric.services[name];
        service.once('ready', async function() {
            for (let i in rpg.config.channels) {
                let channel = rpg.config.channels[i];
                let members = [];
                let present = false;

                try {
                    members = await service._getMembers(channel);
                } catch (E) {
                    rpg.error(`Couldn't get members for "${channel}":`, E);
                }

                if (members) {
                    rpg.channels.push(channel);
                    present = members.includes(service.self.id);
                }

                if (!present) {
                    await service.join(channel);
                }
            }
        });
    }

    rpg.clock = setInterval(function() {
        try {
            rpg.tick();
        } catch (E) {
            console.error('error ticking:', E);
        }
    }, this.config.interval);

    // TODO: document &amp; test
    rpg.newsletter = schedule.scheduleJob('0 0 9 * * *', async function() {
        let leaderboard = await rpg._handleLeaderboardRequest();
        rpg.announce(`A rooster crows in the distance, signalling the break of dawn.  ${leaderboard}`);
    });

    rpg.emit('ready');

    return rpg;
};

/**
 * Clock frame.  Called once per cycle (tick).
 * @fires {IdleRPG#tick} Emitted once the clock cycle is complete.
 * @return {IdleRPG} Chainable method.
 */
IdleRPG.prototype.tick = async function() {
    console.debug('[IDLERPG]', `Beginning tick: ${new Date()}`);

    let rpg = this;
    let players = await rpg._getActivePlayers().catch(function errorHandler(E) {
        console.error('[IDLERPG]', 'Could not get active players:', E);
    });

    // TODO: determine validity from signatures
    // sum all transaction signatures to achieve single-signature per block
    for (let i in players) {
        await rpg._computeRound(players[i]);
    }

    this.emit('tick');

    return rpg;
};

/**
 * Commit to the current game state.  Writes state to disk, then broadcasts any
 * outstanding changes.
 * @fires {IdleRPG#patches} An array of changes since the last commit.
 * @return {Boolean} Indicates successful commit.
 */
IdleRPG.prototype.commit = async function sign() {
    let rpg = this;
    let ops = [
        { type: 'put', key: '/', value: JSON.stringify(this.state) }
    ];

    for (let name in rpg.state) {
        let op = { type: 'put', key: `/${name}`, value: JSON.stringify(rpg.state[name]) };
        ops.push(op);
    }

    return this.store.batch(ops, function shareChanges() {
        let patches = manager.generate(rpg.observer);
        if (patches.length) rpg.emit('patches', patches);
    });
};

IdleRPG.prototype._computeRound = async function computeRound(player) {
    let rpg = this;

    let profile = await rpg._getProfile(player.id).catch(function(E) {
        console.error('Could not get profile:', E);
    });

    if (!profile) return false;

    // relax the cooldown...
    if (profile.cooldown) {
        profile.cooldown = profile.cooldown - rpg.config.PER_TICK_CAPITAL;
    }

    if (profile.presence === 'online') {
        await rpg.reward(profile);
    }

    return profile;
};

/**
 * Get a {@link Player} profile by ID.
 * @param  {String} id Player ID.
 * @return {Player}    Instance of the {@link Player} object.
 */
IdleRPG.prototype._getProfile = async function(id) {
    let rpg = this;
    let parts = id.split('/');

    if (parts.length === 1) {
        parts = ['local', 'users', id];
    }

    let path = parts.join('/');
    let target = pointer.escape(path);

    let base = new Entity({ id: path });
    let data = Object.assign({}, base, backup, prior);
    let profile = {
        id: data.id,
        name: data.name,
        type: 'Player',
        health: data.health || 100,
        stamina: data.stamina || 100,
        experience: data.experience || 0,
        equipment: Object.assign({}, data.equipment, {
            weapon: data.weapon || null
        }),
        inventory: data.inventory || [],
        presence: data.presence || 'offline',
        effects: data.effects || {},
        wealth: data.wealth || 0
    };

    return profile;
};


IdleRPG.prototype._handleProfileRequest = async function(message) {
    let rpg = this;
    let profile = await rpg._getProfile(message.actor);
    let entity = new Entity(profile);
    let effects = Object.keys(entity.effects);
    let equipment = profile.equipment;
    let response = `You are level **${entity.level}** (having earned **${profile.experience}** experience), with **${profile.stamina}** stamina, **${profile.health}** health, and **${profile.wealth}** &lt;small>IDLE&lt;/small> in wealth.`;

    if (equipment.weapon) {
        response += `  Your current weapon is ${article(equipment.weapon.name)} **${equipment.weapon.name}**, which has **${equipment.weapon.attack}** attack and **${equipment.weapon.durability}** durability.`;
    }

    if (effects.length) {
        response += `  You are currently ${effects[0]}.`;
    } else {
        response += `  No special statuses are currently applied.`;
    }

    return response;
};

IdleRPG.prototype._handleInventoryRequest = async function(message) {
    let rpg = this;
    let profile = await rpg._getProfile(message.actor);
    if (!profile.inventory.length) return `You have no items in your inventory.`;
    let response = `Your inventory:`;

    for (let i in profile.inventory) {
        let item = profile.inventory[i];
        response += `\n- ${article(item.name)} **${item.name}**, with **${item.attack}** attack and **${item.durability}** durability`;
    }

    return response;
};


IdleRPG.prototype._handleMemberlistRequest = async function() {
    let rpg = this;
    let list = await rpg._getPlayers();
    let members = list.map(x => x.name);

    return `Current memberlist for the \`idlerpg\` plugin:\n\n\`\`\`\n${JSON.stringify(members, null, '  ')}\n\`\`\``;
};

/**
 * Gets an up-to-date list of all IdleRPG players.
 * @return {Array} List of players.
 */
IdleRPG.prototype._getPlayers = async function() {
    let rpg = this;
    let players = [];

    for (let name in rpg.fabric.services) {
        let service = rpg.fabric.services[name];
        for (let i in rpg.channels) {
            let members = await service._getMembers(rpg.channels[i]).catch(rpg.error);
            for (let j in members) {
                let path = [name, 'users', members[j]].join('/');
                let profile = await rpg._getProfile(path).catch(rpg.error);
                let player = await rpg._registerPlayer(profile).catch(rpg.error);

                if (player) {
                    player.presence = await service._getPresence(members[j]).catch(rpg.error);
                    players.push(player);
                }
            }
        }
    }

    return players;
};

IdleRPG.prototype._registerPlayer = async function registerPlayer(player) {
    if (!player.id) return console.error('Player must have an "id" property.');

    let rpg = this;
    let parts = player.id.split('/');

    if (parts.length === 1) {
        parts = ['local', 'users', player];
    }

    let id = [parts[0], 'users', parts[2]].join('/');
    let target = pointer.escape(id);
    let path = `/players/${target}`;
    let data = Object.assign({}, player);

    try {
        manager.applyPatch(rpg.state, [{
            op: 'replace',
            path: path,
            value: data
        }]);
    } catch (E) {
        console.error('cannot apply patch:', E);
    }

    await rpg.commit();

    let profile = rpg._GET(`/players/${target}`);

    return profile;
};

/**
 * Takes a {@link User} object and registers it as a player.
 * @param  {User} user User to register as a Player.
 * @return {Player}      Instance of the Player object.
 */
IdleRPG.prototype._registerUser = async function registerUser(user) {
    if (!user.id) return console.error('User must have an "id" property.');
    if (!user.name) return console.error('User must have a "name" property.');

    let rpg = this;
    let parts = user.id.split('/');

    if (parts.length === 1) {
        parts = ['local', 'users', user.id];
    }

    let id = parts.join('/');
    let target = pointer.escape(id);
    let path = `/users/${target}`;
    let profile = await rpg._getProfile(id);

    try {
        manager.applyPatch(rpg.state, [{
            op: 'replace',
            path: path,
            value: profile
        }]);
    } catch (E) {
        console.error('cannot apply patch:', E);
    }

    // save to disk
    await rpg.commit();

    return rpg._GET(path);
};


IdleRPG.prototype._registerService = async function registerService(service) {
    manager.applyPatch(this.state, [{
        op: 'add',
        path: `/services/${service.name}`,
        value: {
            users: {},
            channels: {}
        }
    }]);
    await this.commit();
};

module.exports = IdleRPG;
</code></pre>
        </article>
    </section>




    </div>
    <nav><h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Core.html">Core</a></li><li><a href="IdleRPG.html">IdleRPG</a></li></ul></nav>
    <br class="clear" />
    <footer>
      <a href="https://github.com/FabricLabs/idlerpg">Source Code</a> &middot; <a href="/">Documentation</a> &middot; <a href="https://to.matrix.pub/#idlerpg:verse.im">Play</a> &middot; <a href="https://to.fabric.pub/#idlerpg:matrix.org">Chat</a>
    </footer>
    <script>
      prettyPrint();
    </script>
    <script src="scripts/linenumber.js"></script>
  </body>
</html>
